{"title":"Shallow copy","tag":"glossary/shallow_copy","post":"\n\n{{Sidebar(\"Glossary\")}}\n\nA **shallow copy** of an object is a copy whose properties share the same {{Glossary(\"object reference\", \"references\")}} (point to the same underlying values) as those of the source object from which the copy was made. As a result, when you change either the source or the copy, you may also cause the other object to change too. That behavior contrasts with the behavior of a {{Glossary(\"deep copy\")}}, in which the source and copy are completely independent.\n\nMore formally, two objects `o1` and `o2` are shallow copies if:\n\n1. They are not the same object (`o1 !== o2`).\n2. The properties of `o1` and `o2` have the same names in the same order.\n3. The values of their properties are equal.\n4. Their prototype chains are equal.\n\nSee also the definition of _{{Glossary(\"deep copy\", \"structural equivalence\")}}_.\n\nThe copy of an object whose properties all have primitive values fits the definition of both a {{Glossary(\"deep copy\")}} and a shallow copy. It is somewhat useless to talk about the depth of such a copy, though, because it has no nested properties and we usually talk about deep copying in the context of mutating nested properties.\n\nFor shallow copies, only the top-level properties are copied, not the values of nested objects. Therefore:\n\n- Re-assigning top-level properties of the copy does not affect the source object.\n- Re-assigning nested object properties of the copy does affect the source object.\n\nIn JavaScript, all standard built-in object-copy operations ([spread syntax](/blog/Web/JavaScript/Reference/Operators/Spread_syntax), [`Array.prototype.concat()`](/blog/Web/JavaScript/Reference/Global_Objects/Array/concat), [`Array.prototype.slice()`](/blog/Web/JavaScript/Reference/Global_Objects/Array/slice), [`Array.from()`](/blog/Web/JavaScript/Reference/Global_Objects/Array/from), and [`Object.assign()`](/blog/Web/JavaScript/Reference/Global_Objects/Object/assign)) create shallow copies rather than deep copies.\n\nConsider the following example, in which an `ingredientsList` array object is created, and then an `ingredientsListCopy` object is created by copying that `ingredientsList` object.\n\n```js\nconst ingredientsList = [\"noodles\", { list: [\"eggs\", \"flour\", \"water\"] }];\n\nconst ingredientsListCopy = Array.from(ingredientsList);\nconsole.log(ingredientsListCopy);\n// [\"noodles\",{\"list\":[\"eggs\",\"flour\",\"water\"]}]\n```\n\nRe-assigning the value of a nested property will be visible in both objects.\n\n```js\ningredientsListCopy[1].list = [\"rice flour\", \"water\"];\nconsole.log(ingredientsList[1].list);\n// Array [ \"rice flour\", \"water\" ]\n```\n\nRe-assigning the value of a top-level property (the `0` index in this case) will only be visible in the changed object.\n\n```js\ningredientsListCopy[0] = \"rice noodles\";\nconsole.log(ingredientsList[0]); // noodles\nconsole.log(JSON.stringify(ingredientsListCopy));\n// [\"rice noodles\",{\"list\":[\"rice flour\",\"water\"]}]\nconsole.log(JSON.stringify(ingredientsList));\n// [\"noodles\",{\"list\":[\"rice flour\",\"water\"]}]\n```\n\n## See also\n\n- Related glossary terms:\n  - {{Glossary(\"Deep copy\")}}\n","slug":"ee695642b1e5484aaa916f8d610c8e71","authors":"Admin Es Solution","draft":false,"datecreated":"2025-07-05T10:01:15.344Z","dateupdated":"2025-07-05T10:01:15.344Z","layout":"PostBanner"}